# Advent of Code 2025

## Day 1 (Clojure)

Trying very hard not to hate Clojure, but it's really hard. I just can't get onboard with the REPL paradigm. WDYM live coding? Just use types so you don't have to typecheck by hand in runtime like some kind of animal. Duh.

## Day 2 (Haskell)

While I tried to cast Advent of Code as so many do - to experience a new language - I really wanted to try out Haskell as it sounded as a good fit, even though I have already written a few things in it. Must say, comparing it to Clojure, it's rather arcane and unweildy. I think it's fair to say Scheme is to Clojure what Haskell is to Rust - an impractical arcane step-brother language that works as a didactic device.

## Day 3 (Elixir)

The first language of the lot I have never touched before. I was very sceptical of the `do-end` syntax - having previously worked in Lua, where I had serious reservations - but I must say this was an absolute blast. The language is well designed and practical, providing nice variations of syntax to support different use-cases and intent (I really like the explicit `arity` of function when using HOFs) and it spins up fast (unlike Clojure).


## Languages

Languages to try:

- OCaml
- Scala
- Kotlin (?) (Java-- smh)
- C(++) (?) (I am not sure I feel like inventing a universe)
- Gleam (?) (Love-child of Rust and Elixir)
- Amber
- Roc (?) (Weird and niche language)
- zsh (?) (I wrote unchristian amounts of shell scripts in my life but it sound like fun)
- Nim
- Zig
- Crystal
- F#
- Common Lisp (?) (With my functional leaning I will probably just end up writing Clojure/Scheme ðŸ¤·)

Disqualified languages:

| Language | Reason                            |
|----------|-----------------------------------|
| Rust     | I work in it                      |
| Python   | I work in it (grudgingly)         |
| Go       | I work in it (wishing I did more) |
| JS/TS    | I don't want to                   |
| Lua      | Meh                               |
| Java     | Ugh                               |